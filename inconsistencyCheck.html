<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="sweetalert2.all.min.js"></script>
    <script src="gcodetojs.js"></script>

    <link rel="stylesheet" href="sweetalert2.min.css">
</head>
<style>
    #tin {
        display: none;
    }

    canvas {
        border: 1px solid red;
        transform: scale(-1);
        z-index: -1;
    }

    #controls {
        user-select: none;
        position: fixed;
        top: 20vh;
        left: 20vw;
        background-color: rgba(190, 230, 255, .9);
        transform: scale(1);
        z-index: 999;
    }

    #progfnm {
        user-select: all;
    }


    .box {
        font-size: 12px;
        font-family: Arial;
        border: 2px solid black;
        border-radius: 10px;
    }

    .draggable {
        user-select: none;
        width: 50px;
        height: 50px;
        font-size: 20px;
        position: relative
    }

    #draggableCorner {
        position: absolute;
        font-size: 3em;
        padding: 4px;
        text-align: center;
        background-color: rgba(190, 230, 255, .9);
        left: -40px;
        top: -40px;
    }

    #simspeed,
    #toleranceINP,
    #StartTrimManual,
    #EndTrimManual {
        width: 5em;
    }
</style>

<body>

    <div id="controls" style="zoom:100%;" class="controls slidersPanel box">
        <div class="draggable box" id="draggableCorner">↹dragme</div>
        <h4> - - - -Program:<span id=progfnm>no program loaded</span></h4>
        <fieldset>
            <legend>Load new File/ Export image etc.</legend>
            <input title="select any file that supports Trumpf style blocks and syntax." type="file" id=fileInput
                onchange="loadFileAsText()">
            <button title="saves png to file" id="downloadAsImageBtn" onclick="DownloadCanvasAsImage()">Save
                Image</button>
            <button title="toggles points visibility
            points correspond to gcode lines/steps" id="downloadAsImageBtn" onclick="showpointstog()">Show/hide points
            </button>
            <button title="saves all analysis to txt file" id="downloadReportsBtn" onclick="DownloadReports()">Save
                Reports</button>

        </fieldset>
        <fieldset>
            <legend>Edit</legend>
            <BR> <button onclick="MakeRowUI()">make Row in Y</button>
            <BR> <button onclick="MakeLoopUI()">make a LP(grid nesting)</button>
            WIP feature : ability to reopen and simulate looped file
            <BR> <button onclick="reverseAllBlocks(1)">reverse blocks</button>
            <BR> <button onclick="moveSelectionInTimeUI(-1)">move Selection -1 Block
            </button>
            <button onclick="moveSelectionInTimeUI(1)">move Selection +1 Block</button>
            <BR> <button title="1.renumbers blocks (so numbering follows their order of execution)
                2. renumbers lines 
                3. modifies LST headers to remain consistent with the Trumpf spec" onclick=" DownloadGcode()">Save
                Gcode</button>
            <BR> <button onclick=" deleteSelectedBlocksRange()">deleteSelectedBlocksRange</button>
            <fieldset>
                <legend>Macro Replace</legend>

                <input title="select any file that supports Trumpf style blocks and syntax." type="file"
                    id=macroFileInput onchange="loadMacro()">

                <BR> <button title="replacement takes away the originial block and 
                    replaces it with blocks from macro calculating the coordinates incrementally
                    relative to last coordinates(endpoint) in replaced block "
                    onclick="replaceBlocksWithAMacroUI()">Replace
                    Selected w/Macro</button>
            </fieldset>
        </fieldset>

        <fieldset>
            <legend>Simulation </legend>
            draw component every<input id="simspeed" value="1" onchange="set_simspeed()">ms
            <button onclick="simulate(1)">simulate lines</button>
            <button onclick="simulate(2)">simulate blocks</button>
            <br>Block:<span id="aaaBNO">__</span><br>Line:<span id="aaaNNO">--</span>
            <br><button id="SIMST" onclick="simulate(3)">stop</button>
        </fieldset>
        <fieldset>
            <legend>Block Selection </legend>
            Currently <span id="trimLengthSpan">0</span> Blocks selected

            <fieldset>
                <legend>shift whole selection(useful if non-continuous)</legend>

                <button id="" onclick="shiftSelectionUI(-1)">- 1 Block</button>

                <button id="" onclick="shiftSelectionUI(1)">+ 1 Block</button>

            </fieldset>
            <fieldset>
                <legend>Block Selection start &#x02912</legend>

                <button id="prevBlockStartTrimFBtn" onclick="prevBlockStartTrimBtnClick()">- &#x02912</button>
                <input id="StartTrimManual" value="1" onchange="set_StartTrim()">
                <button id="nextBlockStartTrimBtn" onclick="nextBlockStartTrimBtnClick()">+ &#x02912</button>
                Original Block No: <span id="StartBlockspan">__</span>
            </fieldset>
            <fieldset>
                <legend>Block Selection end &#x2191 &#x02913</legend>

                <button id="prevBlockEndTrimFBtn" onclick="prevBlockEndTrimBtnClick()">- &#x02913</button>
                <input id="EndTrimManual" value="0" onchange="set_EndTrim()">

                <button id="nextBlockEndTrimBtn" onclick="nextBlockEndTrimBtnClick()">+ &#x02913</button>
                Original Block No:<span id="EndBlockspan">__</span>
            </fieldset>
            <fieldset>
                <button title="try to find and select blocks
             that have the largest bounding rectangle area" onclick="findProfiles()">find profiles</button>
                <button onclick="setMetablockFromSelection()">Set Metablock and check</button>
                <button onclick="AutoMetablock1()">AUTO Algorithm 1</button>
                <button onclick="AutoMetablock2()">AUTO Algorithm 2</button>
                <br>tolerance for algorithm comparisons<input id="toleranceINP" value="0.01"
                    onchange="set_tolerance()">mm
                <button title="for last selected , selects all similar 
            (based on bounding box)" onclick="selectSimilarBlocks(tolerance)">select similar to selected
                    Tolerance</button>
            </fieldset>
            <pre id=timetook></pre>
            <pre id=tout></pre>
            <pre id="tin" style="display:none">
        </div>
</pre>
            <script>

                // const templateString = "Hello ${this.name}!";
                // const templateVars = {
                //     name: "world"
                // }

                // const fillTemplate = function (templateString, templateVars) {
                //     return new Function("return `" + templateString + "`;").call(templateVars);
                // }

                // console.log(fillTemplate(templateString, templateVars));


                time_Start = 0;
                textFromFileLoaded = ''
                fnm = '';
                global_points = []
                defOffsetVector = { x: 10, y: 10 };
                /* my tools to make development on mobile phone easier*/
                window.onerror = (...x) => {
                    x[2] = x[2] - 8;
                    console.error(x);
                }

                say = console.log


                sa = x => say(x);
                say(+2)

                reportsAr = []
                report = (...x) => reportsAr.push(x.join('') + "\n")

                p = x => tout.innerText += x
                p2 = x => tout.innerText = x
                pl = x => p(x + "\n")
                as = (...x) => x.join('')
                ap = (...x) => p(as(...x))
                apl = (...x) => pl(as(...x))

                function rep(i, func) {
                    if (func()) {
                        setTimeout(x => rep(func), 100)
                    }

                }





                function saveText(text, filename) {
                    var a = document.createElement('a');
                    a.setAttribute('href', 'data:text/plain;charset=utf-u,' + encodeURIComponent(text));
                    a.setAttribute('download', filename);
                    a.click();
                }







            </script>


            <script src="trumpftoStandardgcode.js"></script>


            </pre>
            <script>
                macroSections = []
                macroBlocks = []
                textFromFileLoaded = '';
                loadedMacroText = '';
                text = '';
                sections = [];
                StartTrim = 0;
                EndTrim = 0;
                blockselection = null;
                global_simulation_repeater = null;
                tolerance = 1;
                sheetZeroLaser1 = { x: 440, y: 1920 }
                sheetZeroLaser2 = { x: 440, y: 1460 }

                toleranceINP.value = tolerance;
                lastSelected = null;
                function DownloadReports() {
                    str = reportsAr.join('')
                    saveText(str, fnm + "blankEZreport.txt")
                }
                glb_show_points = true;
                function showpointstog() {
                    glb_show_points = !glb_show_points
                    drawFromPoints(blocks)
                }
                function operateOnTransformedLSTParts(assembleFunc) {

                    let fnNC = fnm.replace('.LST', '').toUpperCase();
                    let nufnm = fnNC + "X"
                    let msg = "save as (LST headers contain the output filename so they will be changed to suit):"
                    let usrnunm = prompt(msg, nufnm + ".LST")
                    if (usrnunm) {
                        nufnm = usrnunm.replace('.LST', '').toUpperCase();
                    }
                    var regnm = new RegExp(fnNC, 'g')
                    let nu_LST_headers = global_LST_headers.replace(regnm, nufnm)
                    blocks = RenumberProgram(blocks)
                    outputGcodeStr = outputGcode(blocks)
                    return assembleFunc(nufnm, nu_LST_headers, outputGcodeStr, global_LST_footers)

                }



                function DownloadGcode() {
                    operateOnTransformedLSTParts(

                        (nufnm, nu_LST_headers, outputGcodeStr, global_LST_footers) => {
                            console.error("TODO TODO TODO TODO no semicolon before END_OF_PROGRAM monkey fix!!!")
                            str = [nu_LST_headers, outputGcodeStr, ";" + global_LST_footers].join("\n")
                            saveText(str, nufnm + ".LST")
                        })

                }


                function loadFileAsText() {

                    time_Start = Date.now()
                    say("started reading")
                    var fileToLoad = fileInput.files[0];
                    window.fileToLoad = fileToLoad
                    fnm = window.fileToLoad.name

                    var fileReader = new FileReader();
                    fileReader.onload = function (fileLoadedEvent) {
                        textFromFileLoaded = fileLoadedEvent.target.result;
                        startDo()
                    };

                    fileReader.readAsText(fileToLoad, "UTF-8");
                }





                window.onload = _ => {

                    say(3);
                    fnm =
                        // "STENCILSL2.LST"
                        // "STENCILSROWSNU_L2.LST"
                        "GASKETTEST.LST"
                    // "TOLERTEST.LST"
                    // "GASKETTESTX.LST"

                    fetch(fnm)
                        .then(r => r.text())
                        .then(t => { say(4); textFromFileLoaded = t; startDo() })
                }
                blocks = [];
                function startDo() {

                    profiles = null
                    blocks = null
                    sections = []

                    blockselection = null;
                    say("started separating gcode");
                    text = textFromFileLoaded;
                    let indStart = text.indexOf(END_OF_HEADER)
                    // let indStart = text.indexOf(START_TEXT)
                    if (indStart < 0) {
                        return say(`LST FILE missing \"${END_OF_HEADER}\" string`)
                    }
                    indStart = indStart + END_OF_HEADER.length
                    // indStart = indStart + START_TEXT.length
                    let indEnd = text.indexOf(END_OF_PROGRAM)
                    if (indEnd < 0) {
                        say(`LST FILE missing \"${END_OF_PROGRAM}\" string. Maybe Generated on old software`)
                        indEnd = text.length;
                    } else {
                        indEnd = indEnd
                    }
                    global_LST_headers = text.substring(0, indStart)
                    // START_TEXT_INDEX = global_LST_headers.indexOf()
                    // global_LST_headers_DEFS = 
                    global_LST_headers = text.substring(0, indStart)

                    let d1i = global_LST_headers.indexOf("DEF INT")
                    let d2i = global_LST_headers.indexOf("DEF REAL")
                    let d3i = global_LST_headers.indexOf("DEF STRING")

                    let anyDefs = [d1i, d2i, d3i].some(x => x > -1)
                    if (anyDefs) {
                        swal.fire("file contains dynamic variables<BR> Attempting Now to parse the logic to show simulation correctly")

                    }
                    global_LST_footers = text.substring(indEnd, text.length)

                    text = text.substring(indStart, indEnd)
                    say("finished separating gcode");
                    progfnm.innerText = fnm
                    global_points = []
                    sections = interpretGCode(text, global_points)
                    blocks = groupSectionsInBlocks(sections)
                    // blocks = RenumberProgram(blocks)
                    StartTrim = 0
                    EndTrim = blocks.length - 1;
                    EndTrimManual.value = EndTrim + 1;
                    StartTrimManual.value = 0 + 1;
                    StartBlockspan.innerText = blocks[0]._B
                    EndBlockspan.innerText = blocks[blocks.length - 1]._B
                    selectBlocks(0, EndTrim)
                    blocks.flat().forEach(s => s.select = false)
                    trimLengthSpan.innerText = blocks.length + " (not highlighting)"
                    // MakeLoopUI()
                    //test:

                    // outputGcodeStr = outputGcode(blocks)

                    // AutoMetablock2()
                    //                     setMacroFromString(`N30;==================== BLOCK_START 1 ===============
                    // N40; LEAD_IN_START
                    // ;ENTRY_LASER:
                    // BLOCK_1:
                    // N50 G01 X = 0 Y = 0 Z = -197.00 B = 0.00 C = 0.00 F = 173000
                    // N60; LEAD_IN_END
                    // N70 R1 = 0 R2 = 0 R3 = -207.00 R4 = 0.00 R5 = 0.00 R11 = 0.00 R26 = 12.00
                    // N80 TC_CIRC2(5,2.5,0.50,9,10,100,"SS1MM")
                    // N90;======\============== BLOCK_END ======================`)
                    // shiftSelection(-1)
                    // replaceBlocksWithAMacroUI()
                    // drawFromPoints(blocks, true)

                    // console.log(profiles)
                    // blocks.flat().map(s => say(s))
                    // sections.filter(s => !(s.typ in NOT_OFFSETABLE_CMDS)).map(s => say(s.gc))
                    // blocks[profiles.i] = profiles.block

                    drawFromBlocksSIM(blocks, false)
                    return;


                    blocksOriginal = JSON.parse(JSON.stringify(blocks))
                    // checkifRepeatsCorrectly(metablock1, blocks)





                    str = getNumericCode_str_repr(sections)
                    if (window.fileToLoad) {
                        console.log(window.fileToLoad.name)
                    }

                    // console.log(str)

                    return;

                }

                function getSelectionBlocks() {
                    let selectedBlocks = [];
                    blocks.forEach(b, i => {
                        allscsselected = b.map(s => s.select).every(x => x)
                        if (allscsselected) {
                            block.select = true
                            selectBlocks.push(block)
                        }

                    })
                    return selectBlocks;
                }

                function getSelectionSections() {

                    return sections.filter(s => s.select)
                }

                function AutoMetablock1() {
                    metablock1 = findRepeatingSequenceInBlocks(blocks)
                    if (!metablock1) {
                        msg = ("SORRY, ALGORITHM 1 (comparing two halves of block arrays) FAILED AT FINDING REPEATING SEQUENCE:\n needs at least two exact copies at the start of the program. could not find automatically the metablock \n\nit may mean that program 1st part and second part are inconsistent,\n please try other algorithm or select manually")

                        return swal.fire(msg)
                    }
                    Block_select_set(metablock1, true)
                }

                if (typeof Array.prototype.move === "undefined") {
                    Array.prototype.move = function (from, to, howMany = 1) {
                        return this.splice(to, 0, ...this.splice(from, howMany)), this
                    }
                }

                function findProfiles() {
                    profiles = findBiggestBboxesAndTheirIndices(blocks)//findRepeatingSequenceInBlocks(blocks)
                    // Block_select_set(blocks[profiles.i], true)
                    if (!profiles) {

                        msg = ("could not find automatically the metablock it may mean that program 1st part and second part are inconsistent, TODO WIP:please select manually")
                        say(msg)
                        return swal.fire(msg)
                    }
                    if (profiles) {
                        //TODO do not select yet 
                        say(blocks)
                        say(profiles)
                        let Bs = profiles.map(x => x.block)
                        profiles = Bs
                        say("Bs:", Bs)
                        metablock_select_set(Bs, true)
                        trimLengthSpan.innerText = profiles.length + " (non-continuous)"
                        drawFromPoints(blocks)


                        profilesindices = profiles.map(pr => blocks.indexOf(pr))

                        //swal.fire("these are the largest blocks(probably profiles):" + Bs)
                        /*
                        metablocks = splitByMetablock(metablock1, blocks)
                        mbinconsistencies = checkMetablockConsistency(metablock1, metablocks)
                        */
                    }
                }

                function AutoMetablock2() {
                    findProfiles()
                    /*TODO assume easy
                    it always starts with not profile
                    small small BiggerThenlastone
                    smaller than last one
                    smaller than last one
                    TODO 2 get bboxes and sort above non repeating metablocks by its profile bbox minY and avery some number every minX
                    */

                }

                function loadMacro() {

                    time_Start = Date.now()
                    say("started reading")
                    var macrofileToLoad = macroFileInput.files[0];
                    window.macrofileToLoad = macrofileToLoad
                    macrofnm = window.macrofileToLoad.name

                    var macrofileReader = new FileReader();
                    macrofileReader.onload = function (fileLoadedEvent) {
                        loadedMacroText = fileLoadedEvent.target.result;
                        setMacroFromString(loadedMacroText);
                    };

                    macrofileReader.readAsText(macrofileToLoad, "UTF-8");
                }

                function setMacroFromString(loadedMacroText) {
                    macroPoints = []
                    macroSections = interpretGCode(loadedMacroText, macroPoints)
                    macroSectionsOriginal = JSON.parse(JSON.stringify(macroSections))
                    macroBlocks = groupSectionsInBlocks(macroSections)
                    macroBlocksOriginal = JSON.parse(JSON.stringify(macroBlocks))
                }

                function replaceBlocksWithAMacroUI() {
                    replaceBlocksWithAMacro(blockselection)
                }

                function replaceBlocksWithAMacro(blocksToReplace) {
                    if (!macroSections.length) { return swal.fire("load macro file first") }
                    blocksToReplace.forEach(blockToReplace => {

                        reverted = [...blockToReplace].reverse();
                        lastcoordsi = null;
                        hascoords = reverted.some((s, i) => {
                            if (s.params && s.params.x && s.params.y) {
                                lastcoordsi = i
                                return true;
                            }
                        });
                        if (!hascoords) {
                            swal.fire(blockToReplace._B + " block has no coordinates to use for macro")
                        }

                        endpoint = reverted[lastcoordsi]
                        base_x = endpoint.params.x
                        base_y = endpoint.params.y
                        offsetVector = { x: base_x, y: base_y }
                        say({ offsetVector, macroBlocksOriginal })

                        // copymovetranslateBlocksWhere(macroBlocksOriginal,where,offsetVector,targetBlocksArray)
                        macroInstanceBlocks = [translateBlockCopy(macroBlocksOriginal[0], offsetVector)]


                        // macroSections = interpretGCode(text, macroPoints)
                        // macroBlocks = groupSectionsInBlocks(macroSections)
                        oldindexofremovedblock = blocks.indexOf(blockToReplace);
                        say({ oldindexofremovedblock })

                        blocks.splice(oldindexofremovedblock, 1, ...macroInstanceBlocks);
                    })
                    drawFromPoints(blocks)
                }



                function setMetablockFromSelection() {
                    selectBlocks(0, 0)
                    metablock1 = blocks.slice(StartTrim, EndTrim)
                    metablocks = splitByMetablock(metablock1, blocks)
                    mbinconsistencies = checkMetablockConsistency(metablock1, metablocks)
                    drawFromPoints(blocks)
                }

                function prevBlockStartTrimBtnClick() {
                    // EndTrimManual.value = parseInt(EndTrimManual.value) - 1
                    let elINP = StartTrimManual
                    let inc = -1
                    let parsed = parseInt(elINP.value)
                    parsed += inc

                    elINP.value = parsed <= 0 ? 1 : parsed;
                    say("new value:", parsed)

                    set_StartTrim()

                }

                function nextBlockStartTrimBtnClick() {
                    let elINP = StartTrimManual
                    let inc = 1
                    let parsed = parseInt(elINP.value)
                    parsed += inc

                    elINP.value = parsed >= blocks.length ? blocks.length : parsed;

                    say("new value:", parsed)


                    set_StartTrim()

                }
                function prevBlockEndTrimBtnClick() {
                    // EndTrimManual.value = parseInt(EndTrimManual.value) - 1
                    let elINP = EndTrimManual
                    let inc = -1
                    let parsed = parseInt(elINP.value)
                    parsed += inc

                    elINP.value = parsed <= 0 ? 1 : parsed;
                    say("new value:", parsed)
                    set_EndTrim()

                }
                function nextBlockEndTrimBtnClick() {
                    let elINP = EndTrimManual
                    let inc = 1
                    let parsed = parseInt(elINP.value)
                    parsed += inc

                    elINP.value = parsed >= blocks.length ? blocks.length : parsed;

                    say("new value:", parsed)
                    set_EndTrim()

                }

                function simulate(what) {
                    if (what === 3) {

                        global_simulation_repeater.running = !global_simulation_repeater.running
                        if (global_simulation_repeater.running) global_simulation_repeater.repeat()
                        SIMST.innerText = global_simulation_repeater.running ? 'stop' : 'start';
                    } else if (global_simulation_repeater !== null) {
                        global_simulation_repeater.stop();
                        global_simulation_repeater = null;
                    }
                    if (what === 2) {
                        global_simulation_interval = global_simulation_interval < 20 ? 20 : global_simulation_interval;
                        simspeed.value = global_simulation_interval
                        drawFromBlocksSIM(blocks, false)

                    } else if (what === 1) {
                        global_simulation_interval = global_simulation_interval > 2000 ? 2000 : global_simulation_interval;
                        simspeed.value = global_simulation_interval
                        drawFromSectionsSIM(blocks, false)
                    }

                }

                function UIUpdate() {

                    EndTrimManual.value = EndTrim
                    StartTrimManual.value = StartTrim
                    return;
                }

                function set_StartTrim() {
                    StartTrim = parseInt(StartTrimManual.value) - 1
                    // StartTrim = nuStartTrim > blocks.length
                    selectBlocks(StartTrim, EndTrim)
                }
                function set_EndTrim() {
                    EndTrim = parseInt(EndTrimManual.value) - 1
                    selectBlocks(StartTrim, EndTrim)
                }

                function set_tolerance() {
                    tolerance = parseFloat(toleranceINP.value)

                }

                function selectBlocks(start, end) {
                    blocks.flat().forEach(s => {
                        s.select = false;
                    })
                    if (start === end) {
                        blockselection = [blocks[start]]
                    }
                    blockselection = blocks.slice(start, end + 1);
                    say("SELECTION:", { start, end }, "length:", blockselection.length, blockselection)
                    blockselection.forEach(b => { b.select = true })
                    blockselection.flat().forEach(s => {
                        s.select = true
                    })
                    StartBlockspan.innerText = blocks[start]._B
                    if (end >= start) {
                        trimLengthSpan.innerText = blockselection.length
                        EndBlockspan.innerText = blocks[end]._B
                    } else {
                        trimLengthSpan.innerText = 0
                        EndBlockspan.innerText = "invalid"

                    }


                    drawFromPoints(blocks)
                }





                function shiftSelectionUI(dir) {
                    shiftSelection(dir)
                    drawFromPoints(blocks)
                }





                function shiftSelection(dir) {
                    let savedblockselection = blockselection.slice(0, blockselection.length - 1)
                    metablock_select_set(blocks, false)
                    nuSel = []
                    savedblockselection.forEach(b => {
                        let bi = blocks.indexOf(b);
                        let nbi = bi + dir;
                        nuSel.push(blocks[nbi])
                    })
                    metablock_select_set(nuSel, true)

                }


                function moveSelectionInTime(dir) {
                    blockselection.forEach(p => { let pi = blocks.indexOf(p); let holei = pi + dir; blocks.move(holei, pi, 1) })
                }



                function moveSelectionInTimeUI(dir) {
                    blockselection.forEach(p => { let pi = blocks.indexOf(p); let holei = pi + dir; blocks.move(holei, pi, 1) })
                    drawFromPoints(blocks)
                }







                function set_simspeed() {
                    global_simulation_interval = parseInt(simspeed.value || 1)
                }

                function deleteBlockByBlockNumbers(B_nos) {
                    let toDelete = blocks.filter(b => B_nos.includes(b._B))
                    deleteBlocks(blocks, toDelete)
                }

                function deleteSelectedBlocksRange() {
                    say(blockselection)
                    let si = blocks.indexOf(blockselection[0])
                    let ei = blocks.indexOf(blockselection[blockselection.length - 1])
                    blocks.splice(si, ei - si + 1)
                    drawFromPoints(blocks)
                }

                function deleteBlocks(toDelete) {
                    removeItems(blocks, toDelete)
                    drawFromPoints(blocks)
                }


                function reverseAllBlocks() {
                    blocks = ReverseAllProgramBlocksAndRenumberEverything(blocks)
                }

                function getBlockByBNumber(B_no) {
                    return blocks.filter(b => B_no === b._B)[0]
                }

                function makeOptions() {
                    return {
                        start: 0,
                        end: blocks.length,
                        "before copied": null,
                        "after copied": null,
                    };
                }

                //TODO make B_to_I I_to_B updated dicts or funcs

                function copymovetranslateBlocksWhere(blocksToCopyMove, where, offsetVector = defOffsetVector, targetBlocksArray = blocks) {
                    let wh = where;
                    let nubs = blocksToCopyMove.map(b => {
                        return translateBlockCopy(b, offsetVector)
                    })
                    let wi = parseInt(where)
                    if (isNaN(wi)) {
                        wi = wh === "start" ? 0 :
                            wh === "end" ? blocks.length :
                                wh === "before copied" ? (blocks.indexOf(blocksToCopyMove[0])) :
                                    wh === "after copied" ? (blocks.indexOf(blocksToCopyMove[blocksToCopyMove.length - 1])) + 1 :
                                        blocks.length;
                    }

                    blocks.splice(wi, 0, ...nubs);
                }

                function RepeatBlocksinAxis(toRepeat, xory, numberOfTimes = 1, dist = 5) {

                    //let toRepeat = blocks.slice(0, blocks.length)
                    let bbx = calcBoundBox(toRepeat.flat())

                    ov = { x: bbx.rangeX, y: bbx.rangeY }
                    let ov2;
                    if (xory.toLowerCase() === "x") {
                        ov2 = { x: ov.x + dist, y: 0 }
                    } else if (xory.toLowerCase() === "y") {
                        ov2 = { x: 0, y: -(ov.y + dist) }
                    }

                    for (let r = 1; r <= numberOfTimes; r++) {
                        ops.copymovetranslateBlocksWhere(toRepeat, "end", { x: ov2.x * r, y: ov2.y * r })


                    }
                    drawFromPoints(blocks)
                }

                function HowManyWillFitY(blocks, maxY = 1250, dist = 5, bbx) {
                    bbx = calcBoundBox(blocks.flat(), s => s.onoffevap != 0)
                    let nuzero = bbx.maxY + dist // 454.93
                    let repSize = bbx.rangeY + dist
                    let howManyFit = Math.floor(maxY / repSize)
                    return howManyFit
                }

                function HowManyWillFitX(blocks, maxX = 1250, dist = 5, bbx) {

                    bbx = calcBoundBox(blocks.flat(), s => s.onoffevap != 0)
                    let nuzero = bbx.minX - dist // 454.93
                    let repSize = bbx.rangeX + dist
                    let howManyFit = Math.floor(maxX / repSize)
                    return howManyFit
                }

                function MakeRow(toRepeat, maxY, dist = 5) {

                    let hm = HowManyWillFitY(toRepeat, maxY, dist)
                    RepeatBlocksinAxis(toRepeat, "y", hm - 1, dist);
                }

                function MakeLoopUI() {
                    arrh = ['',
                        '<input id="maxYinput" class="swal2-input" value="1250">',
                        'sheet Y size   ',
                        '<input id="distinput" class="swal2-input" value="5">',
                        'distance/clearing between cut',
                        '<input id="mmorrepsinput" type="checkbox" class="swal2-input">',
                        'checkbox for input below if you want to enter value in mm instead of columns(integer)',
                        '<input id="maxXinput" class="swal2-input" value="2">',
                        'max X in rows tick above to enter mm '
                    ];

                    (async () => {

                        const { value: strvs } = await Swal.fire({
                            title: 'Loop Macro - repeat without creating new paths',
                            html: arrh.join("<BR>"),
                            focusConfirm: false,
                            preConfirm: () => {
                                return {
                                    maxY: document.getElementById('maxYinput').value,
                                    dist: document.getElementById('distinput').value,
                                    mmorreps: document.getElementById('mmorrepsinput').checked,
                                    maxX: document.getElementById('maxXinput').value
                                }

                            }
                        })

                        if (!strvs) return;
                        let maxY = parseFloat(strvs.maxY)
                        let dist = parseFloat(strvs.dist)
                        let maxX = parseFloat(strvs.maxX)
                        if ([isNaN(maxY), (isNaN(maxX)), isNaN(dist)].some(x => x)) return swal.fire("invalid parameter");
                        let mmorreps = strvs.mmorreps



                        let bbox =
                            calcBoundBox(blocks.flat(), s => s.onoffevap != 0);
                        toRepeat = blockselection;
                        let hmy = HowManyWillFitY(toRepeat, maxY, dist)
                        let hmx;
                        if (mmorreps) {
                            hmx = HowManyWillFitY(toRepeat, maxX, dist)
                        }
                        else {
                            hmx = maxX
                        }
                        say({ bbox })
                        let partSizeX = bbox.rangeX + dist
                        let partSizeY = bbox.rangeY + dist
                        let totalMaxY = hmy * partSizeY
                        let totalMaxX = hmx * partSizeX
                        let totalRepeatsOrParts = hmx * hmy;


                        let STRING_definitions1 = `DEF INT CV_ROW_Y = 0 ;change if need to restart from specific row/part
DEF INT CV_COL_X = 0 ;change if need to restart from specific column
DEF REAL CV_START_OFFSET_X = 0 ; change if need to offset X (old SETG54(X,Y,Z)) 
DEF REAL CV_START_OFFSET_Y = 0 ; change if need to offset Y (old SETG54(X,Y,Z))
DEF INT CV_COL_X_LAST = ${hmx} ; change if need less columns
DEF INT CV_ROW_Y_LAST = ${hmy} ; do not change unless using offcut (measure how many will fit first)
DEF REAL CV_PART_SIZEY = ${partSizeY.toFixed(2)} ;do not change unless need more distance (size of part)
DEF REAL CV_PART_SIZEX = ${partSizeX.toFixed(2)} ;do not change unless need more distance (size of part)
`
                        let STRING_info = `
; this looped program cuts ${totalRepeatsOrParts} repeats/parts
; in a grid of ${hmy} rows and ${hmx} columns  
; total machining area is ${totalMaxY.toFixed(2)} in Y and ${totalMaxX.toFixed(2)} in X  
; EDITING:in order to edit path(Trutops) :
; comment out two lines starting with GOTOB 
; at the end of the program.
; WARNING! any on-line changes to anything below these lines may result in collision
; loop is created in such a way that moveaway in Z should not be needed
; any move away lines can be added after line saying "MOVEAWAY" near the end of the program
; changes should be performed after discussing with program author/trained staff
; below is commented original copy of original loop settings ( alter only above lines)
; COPY OF ORIGINAL SETTINGS:
;`
                        let STRING_definitionsCopy = STRING_definitions1.split("\n").join("\n;")
                        let STRING_definitions = STRING_definitions1 + STRING_info + STRING_definitionsCopy

                        let STRING_loop_logic = `
; start of loop logic
LP_LOGIC_IN:
; for 
;G01 Z = -100; uncomment for higher travel distance between parts normal is -197
IF CV_COL_X > CV_COL_X_LAST
    GOTOF LP_FIN_OUT
ENDIF

LP_ROW_IN:
IF CV_ROW_Y > CV_ROW_Y_LAST
    G01 Z = 300
    SET_G54(CV_START_OFFSET_X + CV_PART_SIZEX * CV_COL_X, CV_START_OFFSET_Y + CV_PART_SIZEY * CV_COL_Y,0.00);
    SETAXG54(B,0)
    SETAXG54(C,0)
    F = 173000
    TC_TRAFO_OFF
    G500
    G01 Z = 750.00 F = 173000
    G01 B = 0.00 C = 0.00
    TC_TRAFO_ON("BC")
    G54
    GOTOF LP_ROW_OUT
ENDIF

;start of repeated section
`
                        let STRING_loop_inc = `
;end of repeating cut, before any moveaway
LP_INC_IN:
CV_ROW_Y = CV_ROW_Y+1;
GOTOB LP_LOGIC_IN
LP_ROW_OUT:
CV_ROW_Y = 0;
CV_COL_X = CV_COL_X+1
GOTOB LP_LOGIC_IN;
LP_FIN_OUT:
;MOVEAWAY and all program end sequence 
G01 Z = 300
SET_G54(0.00,0.00,0.00);
SETAXG54(B,0)
SETAXG54(C,0)
F = 173000
TC_TRAFO_OFF
G500
G01 Z = 750.00 F = 173000
G01 B = 0.00 C = 0.00
TC_TRAFO_ON("BC")
G54
G01 Y = 430;
`
                        operateOnTransformedLSTParts(
                            (nufnm, nu_LST_headers, outputGcodeStr, global_LST_footers) => {
                                nu_LST_headers
                                str = [nu_LST_headers, STRING_definitions, outputGcodeStr, global_LST_footers].join("\n")
                                //put definitions at the very start of the program
                                nu_LST_headers = nu_LST_headers.replace(START_TEXT, [START_TEXT, STRING_definitions].join("\n"))

                                window.outLST = {
                                    nu_LST_headers, STRING_loop_logic, outputGcodeStr, STRING_loop_inc, global_LST_footers,
                                }
                                console.error("TODO TODO TODO TODO no semicolon before END_OF_PROGRAM monkey fix!!!")
                                outLSTstr = [nu_LST_headers, STRING_loop_logic, outputGcodeStr, STRING_loop_inc, ";" + global_LST_footers].join("\n")


                                // Swal.fire(`remember if you need less 
                                // parts you can always change CV_COL_X_LAST
                                // at the start of the program. This type of repetition 
                                // is easier to modify during on-line programming`+ JSON.stringify(strvs))
                                saveText(outLSTstr, nufnm + ".LST")

                                return;

                            })


                    })()


                }


                function MakeRowUI() {
                    if (!blockselection.length) {
                        return swal.fire("please select blocks to repeat first")
                    }
                    let maxY = prompt("enter sheet Y size in mm", "1250")
                    let dist = prompt("enter distance between blanks mm", "5")
                    if (!maxY) return;
                    if (!dist) return;
                    maxY = parseInt(maxY)
                    dist = parseInt(dist)
                    if (isNaN(maxY)) return;
                    if (isNaN(dist)) return;
                    MakeRow(blockselection, maxY, dist)
                }

                function scaleProgtoFit(maxX, maxY) {
                    throw Error("unimplemented")
                    let bbx = calcBoundBox(blocks.flat())
                    let howbigisOnePart = bbx.rangeY;
                    // let normalised = howbigisOnePart
                    // let scaledmax = howbigisOnePart * 0.5
                    // let scaledbbox = howbigisOnePart
                }




                function moveBlocksBeforeBlock() {

                }

                function selectSimilarBlocks(tol) {
                    say({ tol })
                    //TODO NOW
                    if (blockselection.length > 1) {
                        return swal.fire("select one block only, multiblock similarity not yet supported.")
                    }
                    block1 = blockselection[0]
                    bbox1 = calcBoundBox(block1, s => s.onoffevap !== 0)
                    let similarBlocks = []
                    blocks.forEach(block2 => {
                        let bbox2 = calcBoundBox(block2, s => s.onoffevap !== 0)
                        let nSimSizeB = Bbox1SimilarSizeBBox2(bbox1, bbox2, tol)
                        if (nSimSizeB) {
                            similarBlocks.push(block2)
                        }
                    })
                    metablock_select_set(blocks, false)
                    metablock_select_set(similarBlocks, true)
                    drawFromPoints(blocks)
                }

                function selectEverythingBetweenTwoBlocks(tol) {
                    //TODO NOW for last selected , selects all similar

                }

                function selectEverythingBetweenSelectedAndLastSimilarBlock(tol) {
                    //TODO NOW only one selected block has to be                 

                }



                const ops = { moveSelectionInTime, RepeatBlocksinAxis, deleteSelectedBlocksRange, reverseAllBlocks, deleteBlocks, deleteBlockByBlockNumbers, selectBlocks, copymovetranslateBlocksWhere, getBlockByBNumber }


                //noontz
                //https://stackoverflow.com/questions/11112321/how-to-save-canvas-as-png-image/58652379#58652379
                function DownloadCanvasAsImage() {
                    curBGindex = 1;
                    drawFromPoints(blocks)
                    let downloadLink = document.createElement('a');

                    downloadLink.setAttribute('download', fnm + 'blankEZ.png');
                    canvas.toBlob(function (blob) {
                        let url = URL.createObjectURL(blob);
                        downloadLink.setAttribute('href', url);
                        downloadLink.click();
                    });
                }

                function toggleCanvasTransparency() {
                    curBGindex = (!curBGindex & !curBGindex)
                    curCanvasBG = BGcolors[curBGindex]
                    return curBGindex;
                }

            </script>



            <script>
                var dragged = false
                var mousedowned = false;
                window.addEventListener('load', function () {

                    let obj = draggableCorner

                    var dragged = false
                    var mousedowned = false;
                    obj.addEventListener('mousedown', function () {
                        mousedowned = true;
                        dragged = false

                    }, true)
                    obj.addEventListener('mousemove', function (event) {

                        if (mousedowned) {
                            dragged = true
                            moveControls(event)
                        }
                    }, true)
                    window.addEventListener('mouseup', function () {
                        mousedowned = false;
                        if (dragged == true) {
                            return
                        }
                    }, true)



                    obj.addEventListener('mydragevent', function (event) {
                        event.preventDefault();
                        moveControls(event);
                    }, true)

                    obj.addEventListener('touchmove', function (event) {
                        event.preventDefault();
                        moveControls(event);
                    }, false);

                    obj.addEventListener('', function (event) {
                        event.preventDefault();
                        moveControls(event);
                    }, false);

                    obj.addEventListener('touchcancel', function (event) {
                        event.preventDefault();
                        moveControls(event);
                    }, false);

                    // }

                })

                window.addEventListener('mousedown', function (event) {
                    mousedowned = true;
                    dragged = false
                    moveControls(event);
                }, false)
                window.addEventListener('mousemove', function (event) {

                    if (mousedowned) {
                        dragged = true
                        moveControls(event)
                    }
                }, true)
                window.addEventListener('mouseup', function () {
                    mousedowned = false;
                    if (dragged == true) {
                        return
                    }
                }, true)

                function moveControls(event) {



                    var touch = event.targetTouches ? event.targetTouches[0] : event;
                    if (touch) {
                        // Place element where the finger is

                        var sX = window.pageXOffset;
                        var sY = window.pageYOffset;


                        Ex = touch.pageX < 0 ? "200px" : touch.pageX - sX;
                        Ey = touch.pageY < 0 ? (console.log("touch beyond screen!:" + touch.pageY), '1000px') : touch.pageY - sY;
                        Ex < 100 ? Ex = 100 : 0;
                        Ey < 100 ? Ey = 100 : 0;


                        let parel = event.target.parentElement
                        if (parel) {
                            Tstyle = parel.style;

                            TzoomF = (Tstyle.zoom.replace("%", "") / 100).toFixed(2);



                            eZ.ctrls.cX = Tstyle.left = (Ex / TzoomF).toFixed(2) + 'px';
                            eZ.ctrls.cY = Tstyle.top = (Ey / TzoomF).toFixed(2) + 'px';

                        }

                        // console.log();


                        //event.target.innerText="↹:\n"+ctrls.cX+"\n"+ctrls.cY;
                    }
                }
                var eZ = {
                    ctrls: {
                        cX: 0,
                        cY: 0,
                    }
                }

            </script>


</body>

</html>