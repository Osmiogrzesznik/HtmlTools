<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="sweetalert2.all.min.js"></script>
    <script src="gcodetojs.js"></script>

    <link rel="stylesheet" href="sweetalert2.min.css">
</head>
<style>
    #tin {
        display: none;
    }

    canvas {
        border: 1px solid red;
        transform: scale(-1);
        z-index: -1;
    }

    #controls {
        user-select: none;
        position: fixed;
        top: 20vh;
        left: 20vw;
        background-color: rgba(190, 230, 255, .9);
        transform: scale(1);
        z-index: 999;
    }

    #progfnm {
        user-select: all;
    }


    .box {
        font-size: 12px;
        font-family: Arial;
        border: 2px solid black;
        border-radius: 10px;
    }

    .draggable {
        user-select: none;
        width: 50px;
        height: 50px;
        font-size: 20px;
        position: relative
    }

    #draggableCorner {
        position: absolute;
        font-size: 3em;
        padding: 4px;
        text-align: center;
        background-color: rgba(190, 230, 255, .9);
        left: -40px;
        top: -40px;
    }

    #simspeed,
    #toleranceINP,
    #StartTrimManual,
    #EndTrimManual,
    #scaleInput,
    #lineWInput {
        width: 5em;
    }
</style>

<body>

    <div id="controls" style="zoom:100%;" class="controls slidersPanel box">
        <div class="draggable box" id="draggableCorner">â†¹dragme</div>
        <h4> - - - -Program:<span id=progfnm>no program loaded</span></h4>
        <fieldset>
            <legend>Load new File/ Export image etc.</legend>
            <input title="select any file that supports Trumpf style blocks and syntax." type="file" id=fileInput
                onchange="loadFileAsText()">
            <button title="saves png to file" id="downloadAsImageBtn" onclick="DownloadCanvasAsImage()">Save
                Image</button>
            ? <button title="toggles points visibility
            points correspond to gcode lines/steps" id="downloadAsImageBtn" onclick="showpointstog()">Show/hide points
            </button>
            <button title="saves all analysis to txt file" id="downloadReportsBtn" onclick="DownloadReports()">Save
                Reports</button>
                
                

                    <button title="saves all points to file" id="downloadReportsBtn" onclick="savesimple()">Save simple</button>
            <input id="scaleInput" value="8" onchange="set_scale()">scale
            <input id="lineWInput" value="8" onchange="set_lw()">line width


        </fieldset>
        <fieldset>
            <legend>Edit</legend>
            <BR> <button onclick="MakeRowUI()">make Row in Y</button>
            <BR> <button onclick="MakeLoopUI()">make a LP(grid nesting)</button>
            WIP feature : ability to reopen and simulate looped file
            <BR> <button onclick="reverseAllBlocks(1)">reverse blocks</button>
            <BR> <button onclick="moveSelectionInTimeUI(-1)">move Selection -1 Block
            </button>
            <button onclick="moveSelectionInTimeUI(1)">move Selection +1 Block</button>
            <BR> <button title="1.renumbers blocks (so numbering follows their order of execution)
                2. renumbers lines 
                3. modifies LST headers to remain consistent with the Trumpf spec" onclick=" DownloadGcode()">Save
                Gcode</button>
            <BR> <button onclick=" deleteSelectedBlocksRange()">deleteSelectedBlocksRange</button>
            <button onclick=" deleteNonSelected()">deleteNonSelected</button>
            <fieldset>
                <legend>Macro Replace</legend>

                <input title="select any file that supports Trumpf style blocks and syntax." type="file"
                    id=macroFileInput onchange="loadMacro()">

                <BR> <button title="replacement takes away the originial block and 
                    replaces it with blocks from macro calculating the coordinates incrementally
                    relative to last coordinates(endpoint) in replaced block "
                    onclick="replaceBlocksWithAMacroUI()">Replace
                    Selected w/Macro</button>
            </fieldset>
        </fieldset>

        <fieldset>
            <legend>Simulation </legend>
            draw component every<input id="simspeed" value="1" onchange="set_simspeed()">ms
            <button onclick="simulate(1)">simulate lines</button>
            <button onclick="simulate(2)">simulate blocks</button>
            <br>Block:<span id="aaaBNO">__</span><br>Line:<span id="aaaNNO">--</span>
            <br><button id="SIMST" onclick="simulate(3)">stop</button>
        </fieldset>
        <fieldset>
            <legend>Block Selection </legend>
            Currently <span id="trimLengthSpan">0</span> Blocks selected

            <fieldset>
                <legend>shift whole selection(useful if non-continuous)</legend>

                <button id="" onclick="shiftSelectionUI(-1)">- 1 Block</button>

                <button id="" onclick="shiftSelectionUI(1)">+ 1 Block</button>

            </fieldset>
            <fieldset>
                <legend>Block Selection start &#x02912</legend>

                <button id="prevBlockStartTrimFBtn" onclick="prevBlockStartTrimBtnClick()">- &#x02912</button>
                <input id="StartTrimManual" value="1" onchange="set_StartTrim()">
                <button id="nextBlockStartTrimBtn" onclick="nextBlockStartTrimBtnClick()">+ &#x02912</button>
                Original Block No: <span id="StartBlockspan">__</span>
            </fieldset>
            <fieldset>
                <legend>Block Selection end &#x2191 &#x02913</legend>

                <button id="prevBlockEndTrimFBtn" onclick="prevBlockEndTrimBtnClick()">- &#x02913</button>
                <input id="EndTrimManual" value="0" onchange="set_EndTrim()">

                <button id="nextBlockEndTrimBtn" onclick="nextBlockEndTrimBtnClick()">+ &#x02913</button>
                Original Block No:<span id="EndBlockspan">__</span>
            </fieldset>
            <fieldset>
                <button title="try to find and select blocks
             that have the largest bounding rectangle area" onclick="findProfiles()">find profiles</button>
                 <button title="try to find and select blocks
             that have the largest bounding rectangle area" onclick="findProfiles1()">find profile1</button>
                <button onclick="setMetablockFromSelection()">Set Metablock and check</button>
                <button onclick="AutoMetablock1()">AUTO Algorithm 1</button>
                <button onclick="AutoMetablock2()">AUTO Algorithm 2</button>
                <br>tolerance for algorithm comparisons<input id="toleranceINP" value="0.01"
                    onchange="set_tolerance()">mm
                <button title="for last selected , selects all similar 
            (based on bounding box)" onclick="selectSimilarBlocks(tolerance)">select similar to selected
                    Tolerance</button>
            </fieldset>
            <pre id=timetook></pre>
            <pre id=tout></pre>
            <pre id="tin" style="display:none">
        </div>
</pre>
            <script>
function savesimple() {
  let nufnm = 'gowno nie wiem'
 str = outputGcode2(blocks)       
saveText(str, nufnm + ".LST.c")                                    }
                









                // const templateString = "Hello ${this.name}!";
                // const templateVars = {
                //     name: "world"
                // }

                // const fillTemplate = function (templateString, templateVars) {
                //     return new Function("return `" + templateString + "`;").call(templateVars);
                // }

                // console.log(fillTemplate(templateString, templateVars));
                
   class StringSplitter {
    constructor(inputString) {
        this.linesArray = inputString.split('\n');
    }

    insertAfter(stringToFind, stringToInsert) {
        const foundIndex = this.linesArray.findIndex(line => line.includes(stringToFind));

        if (foundIndex !== -1) {
            const linesToInsert = stringToInsert.split('\n');
            this.linesArray.splice(foundIndex + 1, 0, ...linesToInsert);
        }

        return this;
    }

    toString() {
        return this.linesArray.join('\n');
    }
}
             
                
                
                
                function set_scale() {
                    ctx_scl = parseFloat(scaleInput.value)
                    drawFromPoints(blocks)
                }

                function set_lw() {
                    currentLineWidth = parseFloat(lineWInput.value)
                    drawFromPoints(blocks)
                }

                time_Start = 0;
                textFromFileLoaded = ''
                fnm = '';
                global_points = []
                defOffsetVector = { x: 10, y: 10 };
                /* my tools to make development on mobile phone easier*/
                window.onerror = (...x) => {
                    x[2] = x[2] - 8;
                    console.error(x);
                }

                say = console.log


                sa = x => say(x);
                say(+2)

                reportsAr = []
                report = (...x) => reportsAr.push(x.join('') + "\n")

                p = x => tout.innerText += x
                p2 = x => tout.innerText = x
                pl = x => p(x + "\n")
                as = (...x) => x.join('')
                ap = (...x) => p(as(...x))
                apl = (...x) => pl(as(...x))

                function rep(i, func) {
                    if (func()) {
                        setTimeout(x => rep(func), 100)
                    }

                }





                function saveText(text, filename) {
                    var a = document.createElement('a');
                    a.setAttribute('href', 'data:text/plain;charset=utf-u,' + encodeURIComponent(text));
                    a.setAttribute('download', filename);
                    a.click();
                }







            </script>


            <script src="trumpftoStandardgcode.js"></script>


            </pre>
            <script>
                macroSections = []
                macroBlocks = []
                textFromFileLoaded = '';
                loadedMacroText = '';
                text = '';
                sections = [];
                StartTrim = 0;
                EndTrim = 0;
                blockselection = null;
                global_simulation_repeater = null;
                tolerance = 1;
                sheetZeroLaser1 = { x: 440, y: 1920 }
                sheetZeroLaser2 = { x: 440, y: 1460 }

                toleranceINP.value = tolerance;
                lastSelected = null;
                function DownloadReports() {
                    str = reportsAr.join('')
                    saveText(str, fnm + "blankEZreport.txt")
                }
                glb_show_points = false;
                function showpointstog() {
                    glb_show_points = !glb_show_points
                    drawFromPoints(blocks)
                }
                function operateOnTransformedLSTParts(assembleFunc) {

                    let fnNC = fnm.replace('.LST', '').toUpperCase();
                    let nufnm = fnNC + "X"
                    let msg = "save as (LST headers contain the output filename so they will be changed to suit):"
                    let usrnunm = prompt(msg, nufnm + ".LST")
                    if (usrnunm) {
                        nufnm = usrnunm.replace('.LST', '').toUpperCase();
                    }
                    var regnm = new RegExp(fnNC, 'g')
                    let nu_LST_headers = global_LST_headers.replace(regnm, nufnm)
                    blocks = RenumberProgram(blocks)
                    outputGcodeStr = outputGcode(blocks)
                    return assembleFunc(nufnm, nu_LST_headers, outputGcodeStr, global_LST_footers)

                }



                function DownloadGcode() {
                    operateOnTransformedLSTParts(

                        (nufnm, nu_LST_headers, outputGcodeStr, global_LST_footers) => {
                            console.error("TODO TODO TODO TODO no semicolon before END_OF_PROGRAM monkey fix!!!")
                            str = [nu_LST_headers, outputGcodeStr, ";" + global_LST_footers].join("\n")
                            saveText(str, nufnm + ".LST")
                        })

                }


                function loadFileAsText() {

                    time_Start = Date.now()
                    say("started reading")
                    var fileToLoad = fileInput.files[0];
                    window.fileToLoad = fileToLoad
                    fnm = window.fileToLoad.name

                    var fileReader = new FileReader();
                    fileReader.onload = function (fileLoadedEvent) {
                        textFromFileLoaded = fileLoadedEvent.target.result;
                        startDo()
                    };

                    fileReader.readAsText(fileToLoad, "UTF-8");
                }





                window.onload = _ => {

                    say(3);
                    fnm =
                        // "STENCILSL2.LST"
                        // "STENCILSROWSNU_L2.LST"
                        "DONE/EXMPLPART.LST"
                    // "QRBCSCWD1.LST"
                    // "TOLERTEST.LST"


                    fetch(fnm)
                        .then(r => r.text())
                        .then(t => { say(4); textFromFileLoaded = t; startDo() })
                }
                blocks = [];
                function startDo() {
                    scaleInput.value = ctx_scl
                    lineWInput.value = currentLineWidth
                    profiles = null
                    blocks = null
                    sections = []

                    blockselection = null;
                    say("started separating gcode");
                    text = textFromFileLoaded;
                    let indStart = text.indexOf(END_OF_HEADER)
                    // let indStart = text.indexOf(START_TEXT)
                    if (indStart < 0) {
                        return say(`LST FILE missing \"${END_OF_HEADER}\" string`)
                    }
                    indStart = indStart + END_OF_HEADER.length
                    // indStart = indStart + START_TEXT.length
                    let indEnd = text.indexOf(END_OF_PROGRAM)
                    if (indEnd < 0) {
                        say(`LST FILE missing \"${END_OF_PROGRAM}\" string. Maybe Generated on old software`)
                        indEnd = text.length;
                    } else {
                        indEnd = indEnd
                    }
                    global_LST_headers = text.substring(0, indStart)
                    // START_TEXT_INDEX = global_LST_headers.indexOf()
                    // global_LST_headers_DEFS = 
                    global_LST_headers = text.substring(0, indStart)

                    let d1i = global_LST_headers.indexOf("DEF INT")
                    let d2i = global_LST_headers.indexOf("DEF REAL")
                    let d3i = global_LST_headers.indexOf("DEF STRING")

                    let anyDefs = [d1i, d2i, d3i].some(x => x > -1)
                    if (anyDefs) {
                        swal.fire("file contains dynamic variables<BR> Attempting Now to parse the logic to show simulation correctly")

                    }
                    global_LST_footers = text.substring(indEnd, text.length)

                    text = text.substring(indStart, indEnd)
                    say("finished separating gcode");
                    progfnm.innerText = fnm
                    global_points = []
                    sections = interpretGCode(text, global_points)
                    blocks = groupSectionsInBlocks(sections)
                    // blocks = RenumberProgram(blocks)
                    StartTrim = 0
                    EndTrim = blocks.length - 1;
                    EndTrimManual.value = EndTrim + 1;
                    StartTrimManual.value = 0 + 1;
                    StartBlockspan.innerText = blocks[0]._B
                    EndBlockspan.innerText = blocks[blocks.length - 1]._B
                    selectBlocks(0, EndTrim)
                    blocks.flat().forEach(s => s.select = false)
                    trimLengthSpan.innerText = blocks.length + " (not highlighting)"
                    // MakeLoopUI()
                    //test:

                    // outputGcodeStr = outputGcode(blocks)

                    // AutoMetablock2()
                    //                     setMacroFromString(`N30;==================== BLOCK_START 1 ===============
                    // N40; LEAD_IN_START
                    // ;ENTRY_LASER:
                    // BLOCK_1:
                    // N50 G01 X = 0 Y = 0 Z = -197.00 B = 0.00 C = 0.00 F = 173000
                    // N60; LEAD_IN_END
                    // N70 R1 = 0 R2 = 0 R3 = -207.00 R4 = 0.00 R5 = 0.00 R11 = 0.00 R26 = 12.00
                    // N80 TC_CIRC2(5,2.5,0.50,9,10,100,"SS1MM")
                    // N90;======\============== BLOCK_END ======================`)
                    // shiftSelection(-1)
                    // replaceBlocksWithAMacroUI()
                    // drawFromPoints(blocks, true)

                    // console.log(profiles)
                    // blocks.flat().map(s => say(s))
                    // sections.filter(s => !(s.typ in NOT_OFFSETABLE_CMDS)).map(s => say(s.gc))
                    // blocks[profiles.i] = profiles.block

                    drawFromBlocksSIM(blocks, false)
                    return;


                    blocksOriginal = JSON.parse(JSON.stringify(blocks))
                    // checkifRepeatsCorrectly(metablock1, blocks)





                    str = getNumericCode_str_repr(sections)
                    if (window.fileToLoad) {
                        console.log(window.fileToLoad.name)
                    }

                    // console.log(str)

                    return;

                }

                function getSelectionBlocks() {
                    let selectedBlocks = [];
                    blocks.forEach(b, i => {
                        allscsselected = b.map(s => s.select).every(x => x)
                        if (allscsselected) {
                            block.select = true
                            selectBlocks.push(block)
                        }

                    })
                    return selectBlocks;
                }

                function getSelectionSections() {

                    return sections.filter(s => s.select)
                }

                function AutoMetablock1() {
                    metablock1 = findRepeatingSequenceInBlocks(blocks)
                    if (!metablock1) {
                        msg = ("SORRY, ALGORITHM 1 (comparing two halves of block arrays) FAILED AT FINDING REPEATING SEQUENCE:\n needs at least two exact copies at the start of the program. could not find automatically the metablock \n\nit may mean that program 1st part and second part are inconsistent,\n please try other algorithm or select manually")

                        return swal.fire(msg)
                    }
                    Block_select_set(metablock1, true)
                }

                if (typeof Array.prototype.move === "undefined") {
                    Array.prototype.move = function (from, to, howMany = 1) {
                        return this.splice(to, 0, ...this.splice(from, howMany)), this
                    }
                }

                function findProfiles() {
                    profiles = findBiggestBboxesAndTheirIndices(blocks)//findRepeatingSequenceInBlocks(blocks)
                    // Block_select_set(blocks[profiles.i], true)
                    if (!profiles) {

                        msg = ("could not find automatically the metablock it may mean that program 1st part and second part are inconsistent, TODO WIP:please select manually")
                        say(msg)
                        return swal.fire(msg)
                    }
                    if (profiles) {
                        //TODO do not select yet 
                        say(blocks)
                        say(profiles)
                        let Bs = profiles.map(x => x.block)
                        profiles = Bs
                        say("Bs:", Bs)
                        metablock_select_set(Bs, true)
                        trimLengthSpan.innerText = profiles.length + " (non-continuous)"
                        drawFromPoints(blocks)


                        profilesindices = profiles.map(pr => blocks.indexOf(pr))

                        //swal.fire("these are the largest blocks(probably profiles):" + Bs)
                        /*
                        metablocks = splitByMetablock(metablock1, blocks)
                        mbinconsistencies = checkMetablockConsistency(metablock1, metablocks)
                        */
                    }
                }
                
                function findProfiles1() {
                    profiles = findBiggestBboxesAndTheirIndices(blocks)
                    if (!profiles) {

                        msg = ("could not find automatically the metablock it may mean that program 1st part and second part are inconsistent, TODO WIP:please select manually")
                        say(msg)
                        return swal.fire(msg)
                    }
                    if (profiles) {
                        //TODO do not select yet 
                        say(blocks)
                        say(profiles)
                        profiles= [profiles[0]]
                        let Bs = profiles.map(x => x.block)
                        profiles = Bs
                        say("Bs:", Bs)
                        metablock_select_set(Bs, true)
                        trimLengthSpan.innerText = profiles.length + " first profile"
                        drawFromPoints(blocks)


                        profilesindices = profiles.map(pr => blocks.indexOf(pr))

                        
                    }
                }

                function AutoMetablock2() {
                    findProfiles()
                    /*TODO assume easy
                    it always starts with not profile
                    small small BiggerThenlastone
                    smaller than last one
                    smaller than last one
                    TODO 2 get bboxes and sort above non repeating metablocks by its profile bbox minY and avery some number every minX
                    */

                }

                function loadMacro() {

                    time_Start = Date.now()
                    say("started reading")
                    var macrofileToLoad = macroFileInput.files[0];
                    window.macrofileToLoad = macrofileToLoad
                    macrofnm = window.macrofileToLoad.name

                    var macrofileReader = new FileReader();
                    macrofileReader.onload = function (fileLoadedEvent) {
                        loadedMacroText = fileLoadedEvent.target.result;
                        setMacroFromString(loadedMacroText);
                    };

                    macrofileReader.readAsText(macrofileToLoad, "UTF-8");
                }

                function setMacroFromString(loadedMacroText) {
                    macroPoints = []
                    macroSections = interpretGCode(loadedMacroText, macroPoints)
                    macroSectionsOriginal = JSON.parse(JSON.stringify(macroSections))
                    macroBlocks = groupSectionsInBlocks(macroSections)
                    macroBlocksOriginal = JSON.parse(JSON.stringify(macroBlocks))
                }

                function replaceBlocksWithAMacroUI() {
                    replaceBlocksWithAMacro(blockselection)
                }

                function replaceBlocksWithAMacro(blocksToReplace) {
                    if (!macroSections.length) { return swal.fire("load macro file first") }
                    blocksToReplace.forEach(blockToReplace => {

                        reverted = [...blockToReplace].reverse();
                        lastcoordsi = null;
                        hascoords = reverted.some((s, i) => {
                            if (s.params && s.params.x && s.params.y) {
                                lastcoordsi = i
                                return true;
                            }
                        });
                        if (!hascoords) {
                            swal.fire(blockToReplace._B + " block has no coordinates to use for macro")
                        }

                        endpoint = reverted[lastcoordsi]
                        base_x = endpoint.params.x
                        base_y = endpoint.params.y
                        offsetVector = { x: base_x, y: base_y }
                        say({ offsetVector, macroBlocksOriginal })

                        // copymovetranslateBlocksWhere(macroBlocksOriginal,where,offsetVector,targetBlocksArray)
                        macroInstanceBlocks = [translateBlockCopy(macroBlocksOriginal[0], offsetVector)]


                        // macroSections = interpretGCode(text, macroPoints)
                        // macroBlocks = groupSectionsInBlocks(macroSections)
                        oldindexofremovedblock = blocks.indexOf(blockToReplace);
                        say({ oldindexofremovedblock })

                        blocks.splice(oldindexofremovedblock, 1, ...macroInstanceBlocks);
                    })
                    drawFromPoints(blocks)
                }



                function setMetablockFromSelection() {
                    selectBlocks(0, 0)
                    metablock1 = blocks.slice(StartTrim, EndTrim)
                    metablocks = splitByMetablock(metablock1, blocks)
                    mbinconsistencies = checkMetablockConsistency(metablock1, metablocks)
                    drawFromPoints(blocks)
                }

                function prevBlockStartTrimBtnClick() {
                    // EndTrimManual.value = parseInt(EndTrimManual.value) - 1
                    let elINP = StartTrimManual
                    let inc = -1
                    let parsed = parseInt(elINP.value)
                    parsed += inc

                    elINP.value = parsed <= 0 ? 1 : parsed;
                    say("new value:", parsed)

                    set_StartTrim()

                }

                function nextBlockStartTrimBtnClick() {
                    let elINP = StartTrimManual
                    let inc = 1
                    let parsed = parseInt(elINP.value)
                    parsed += inc

                    elINP.value = parsed >= blocks.length ? blocks.length : parsed;

                    say("new value:", parsed)


                    set_StartTrim()

                }
                function prevBlockEndTrimBtnClick() {
                    // EndTrimManual.value = parseInt(EndTrimManual.value) - 1
                    let elINP = EndTrimManual
                    let inc = -1
                    let parsed = parseInt(elINP.value)
                    parsed += inc

                    elINP.value = parsed <= 0 ? 1 : parsed;
                    say("new value:", parsed)
                    set_EndTrim()

                }
                function nextBlockEndTrimBtnClick() {
                    let elINP = EndTrimManual
                    let inc = 1
                    let parsed = parseInt(elINP.value)
                    parsed += inc

                    elINP.value = parsed >= blocks.length ? blocks.length : parsed;

                    say("new value:", parsed)
                    set_EndTrim()

                }

                function simulate(what) {
                    if (what === 3) {

                        global_simulation_repeater.running = !global_simulation_repeater.running
                        if (global_simulation_repeater.running) global_simulation_repeater.repeat()
                        SIMST.innerText = global_simulation_repeater.running ? 'stop' : 'start';
                    } else if (global_simulation_repeater !== null) {
                        global_simulation_repeater.stop();
                        global_simulation_repeater = null;
                    }
                    if (what === 2) {
                        global_simulation_interval = global_simulation_interval < 20 ? 20 : global_simulation_interval;
                        simspeed.value = global_simulation_interval
                        drawFromBlocksSIM(blocks, false)

                    } else if (what === 1) {
                        global_simulation_interval = global_simulation_interval > 2000 ? 2000 : global_simulation_interval;
                        simspeed.value = global_simulation_interval
                        drawFromSectionsSIM(blocks, false)
                    }

                }

                function UIUpdate() {

                    EndTrimManual.value = EndTrim
                    StartTrimManual.value = StartTrim
                    return;
                }

                function set_StartTrim() {
                    StartTrim = parseInt(StartTrimManual.value) - 1
                    // StartTrim = nuStartTrim > blocks.length
                    selectBlocks(StartTrim, EndTrim)
                }
                function set_EndTrim() {
                    EndTrim = parseInt(EndTrimManual.value) - 1
                    selectBlocks(StartTrim, EndTrim)
                }

                function set_tolerance() {
                    tolerance = parseFloat(toleranceINP.value)

                }

                function selectBlocks(start, end) {
                    blocks.flat().forEach(s => {
                        s.select = false;
                    })
                    if (start === end) {
                        blockselection = [blocks[start]]
                    }
                    blockselection = blocks.slice(start, end + 1);
                    say("SELECTION:", { start, end }, "length:", blockselection.length, blockselection)
                    blockselection.forEach(b => { b.select = true })
                    blockselection.flat().forEach(s => {
                        s.select = true
                    })
                    StartBlockspan.innerText = blocks[start]._B
                    if (end >= start) {
                        trimLengthSpan.innerText = blockselection.length
                        EndBlockspan.innerText = blocks[end]._B
                    } else {
                        trimLengthSpan.innerText = 0
                        EndBlockspan.innerText = "invalid"

                    }


                    drawFromPoints(blocks)
                }





                function shiftSelectionUI(dir) {
                    shiftSelection(dir)
                    drawFromPoints(blocks)
                }





                function shiftSelection(dir) {
                    let savedblockselection = blockselection.slice(0, blockselection.length - 1)
                    metablock_select_set(blocks, false)
                    nuSel = []
                    savedblockselection.forEach(b => {
                        let bi = blocks.indexOf(b);
                        let nbi = bi + dir;
                        nuSel.push(blocks[nbi])
                    })
                    metablock_select_set(nuSel, true)

                }


                function moveSelectionInTime(dir) {
                    blockselection.forEach(p => { let pi = blocks.indexOf(p); let holei = pi + dir; blocks.move(holei, pi, 1) })
                }



                function moveSelectionInTimeUI(dir) {
                    blockselection.forEach(p => { let pi = blocks.indexOf(p); let holei = pi + dir; blocks.move(holei, pi, 1) })
                    drawFromPoints(blocks)
                }







                function set_simspeed() {
                    global_simulation_interval = parseInt(simspeed.value || 1)
                }

                function deleteBlockByBlockNumbers(B_nos) {
                    let toDelete = blocks.filter(b => B_nos.includes(b._B))
                    deleteBlocks(blocks, toDelete)
                }

                function deleteSelectedBlocksRange() {
                    say(blockselection)
                    
                    drawFromPoints(blocks)
                }

function deleteNonSelected() {
                    say(blockselection)
                    blocks = blockselection
                    drawFromPoints(blocks)
                }


                function deleteBlocks(toDelete) {
                    removeItems(blocks, toDelete)
                    drawFromPoints(blocks)
                }


                function reverseAllBlocks() {
                    blocks = ReverseAllProgramBlocksAndRenumberEverything(blocks)
                }

                function getBlockByBNumber(B_no) {
                    return blocks.filter(b => B_no === b._B)[0]
                }

                function makeOptions() {
                    return {
                        start: 0,
                        end: blocks.length,
                        "before copied": null,
                        "after copied": null,
                    };
                }

                //TODO make B_to_I I_to_B updated dicts or funcs

                function copymovetranslateBlocksWhere(blocksToCopyMove, where, offsetVector = defOffsetVector, targetBlocksArray = blocks) {
                    let wh = where;
                    let nubs = blocksToCopyMove.map(b => {
                        return translateBlockCopy(b, offsetVector)
                    })
                    let wi = parseInt(where)
                    if (isNaN(wi)) {
                        wi = wh === "start" ? 0 :
                            wh === "end" ? blocks.length :
                                wh === "before copied" ? (blocks.indexOf(blocksToCopyMove[0])) :
                                    wh === "after copied" ? (blocks.indexOf(blocksToCopyMove[blocksToCopyMove.length - 1])) + 1 :
                                        blocks.length;
                    }

                    blocks.splice(wi, 0, ...nubs);
                }

                function RepeatBlocksinAxis(toRepeat, xory, numberOfTimes = 1, dist = 5) {

                    //let toRepeat = blocks.slice(0, blocks.length)
                    let bbx = calcBoundBox(toRepeat.flat())

                    ov = { x: bbx.rangeX, y: bbx.rangeY }
                    let ov2;
                    if (xory.toLowerCase() === "x") {
                        ov2 = { x: ov.x + dist, y: 0 }
                    } else if (xory.toLowerCase() === "y") {
                        ov2 = { x: 0, y: -(ov.y + dist) }
                    }

                    for (let r = 1; r <= numberOfTimes; r++) {
                        ops.copymovetranslateBlocksWhere(toRepeat, "end", { x: ov2.x * r, y: ov2.y * r })


                    }
                    drawFromPoints(blocks)
                }

                function HowManyWillFitY(blocks, maxY = 1250, dist = 5, bbx) {
                    bbx = calcBoundBox(blocks.flat(), s => s.onoffevap != 0)
                    let nuzero = bbx.maxY + dist // 454.93
                    let repSize = bbx.rangeY + dist
                    let howManyFit = Math.floor(maxY / repSize)
                    return howManyFit
                }

                function HowManyWillFitX(blocks, maxX = 1250, dist = 5, bbx) {

                    bbx = calcBoundBox(blocks.flat(), s => s.onoffevap != 0)
                    let nuzero = bbx.minX - dist // 454.93
                    let repSize = bbx.rangeX + dist
                    let howManyFit = Math.floor(maxX / repSize)
                    return howManyFit
                }

                function MakeRow(toRepeat, maxY, dist = 5) {

                    let hm = HowManyWillFitY(toRepeat, maxY, dist)
                    RepeatBlocksinAxis(toRepeat, "y", hm - 1, dist);
                }

                function MakeLoopUI() {
                    arrh = ['',
                        '<input id="maxYinput" class="swal2-input" value="1250">',
                        'sheet Y size   ',
                        '<input id="distinput" class="swal2-input" value="5">',
                        'distance/clearing between cut',
                        '<input id="mmorrepsinput" type="checkbox" class="swal2-input">',
                        'checkbox for input below if you want to enter value in mm instead of columns(integer)',
                        '<input id="maxXinput" class="swal2-input" value="2">',
                        'max X in rows tick above to enter mm '
                    ];

                    (async () => {

                        const { value: strvs } = await Swal.fire({
                            title: 'Loop Macro - repeat without creating new paths',
                            html: arrh.join("<BR>"),
                            focusConfirm: false,
                            preConfirm: () => {
                                return {
                                    maxY: document.getElementById('maxYinput').value,
                                    dist: document.getElementById('distinput').value,
                                    mmorreps: document.getElementById('mmorrepsinput').checked,
                                    maxX: document.getElementById('maxXinput').value
                                }

                            }
                        })

                        if (!strvs) return;
                        let maxY = parseFloat(strvs.maxY)
                        let dist = parseFloat(strvs.dist)
                        let maxX = parseFloat(strvs.maxX)
                        if ([isNaN(maxY), (isNaN(maxX)), isNaN(dist)].some(x => x)) return swal.fire("invalid parameter");
                        let mmorreps = strvs.mmorreps



                        let bbox =
                            calcBoundBox(blocks.flat(), s => s.onoffevap != 0);
                        toRepeat = blockselection;
                        let hmy = HowManyWillFitY(toRepeat, maxY, dist)
                        let hmx;
                        if (mmorreps) {
                            hmx = HowManyWillFitY(toRepeat, maxX, dist)
                        }
                        else {
                            hmx = maxX
                        }
                        say({ bbox })
                        let partSizeX = bbox.rangeX + dist
                        let partSizeY = bbox.rangeY + dist
                        let totalMaxY = hmy * partSizeY
                        let totalMaxX = hmx * partSizeX
                        let totalRepeatsOrParts = hmx * hmy;


                        let STRING_definitions1 = 
`;==== START OF REP VARIABLES =====
DEF INT CVLX = 0;
DEF INT CVLY = 0;
DEF INT CVMAXX = ${hmx};
DEF INT CVMAXY = ${hmy};
DEF INT CVREPS = 0;
DEF INT CVMAXREPS = ${totalRepeatsOrParts};
; these are safety to prevent going off sheet
DEF INT CVSHEETX = ${maxX};
DEF INT CVSHEETY = ${maxY};
DEF INT CVPARTX = ${Math.ceil(partSizeX)};include margin
DEF INT CVPARTY = ${Math.ceil(partSizeY)};include margin
;==== END OF REP VARIABLES =====
;start at: 
DEF INT CVLY = 0;start at- change to start later part
DEF INT CVLX = 0;start at- change to start later part
`




                        let STRING_info = 
`; this looped program cuts ${totalRepeatsOrParts} repeats/parts
; in a grid of ${hmy} rows and ${hmx} columns  
; total machining area is ${totalMaxY.toFixed(2)} in Y and ${totalMaxX.toFixed(2)} in X  
; EDITING:in order to edit path(Trutops) :
; comment out line starting with GOTOB 
; at the end of the program.
; WARNING! any on-line changes to anything below these lines may result in collision
; loop is created in such a way that moveaway in Z should not be needed
; any move away lines can be added after line saying "MOVEAWAY" near the end of the program
; changes should be performed after discussing with program author/trained staff
; below is commented original copy of original loop settings ( alter only above lines)
; COPY OF ORIGINAL SETTINGS:
;`
                        let STRING_definitionsCopy = STRING_definitions1.split("\n").join("\n;")
                        let STRING_definitions = STRING_definitions1 + STRING_info + STRING_definitionsCopy

                        let STRING_loop_logic = 
`REPSTART_SETG54:
G4 F5.0
SET_G54(CVPARTX*CVLX, CVPARTY*-CVLY, 0.00)
`
                        let STRING_loop_inc = 
`;=========START OF REP LOGIC=======
REPLOGIC:
Z=400
TC_LASER_OFF(2)
CVREPS = CVREPS+1

IF CVREPS >= CVMAXREPS
   GOTOF PROG_END
ENDIF

IF CVLY >= CVMAXY 
   IF CVLX >= CVMAXX 
     GOTOF PROG_END
   ELSE
     CVLX = CVLX+1
     	IF CVPARTX*(CVLX+1) > CVSHEETX
     		MSG("stopping! NEXT PART OFF SHEET!" << CVPARTX*(CVLX+1));
			GOTOF PROG_END
		 ENDIF
     CVLY = 0
     MSG("XmaxLeft:" << CVPARTX*(CVLX+1)) << " YmaxTop:" << CVPARTY*(CVLY+1));
   ENDIF
ELSE
CVLY = CVLY+1
	IF CVPARTY*(CVLY+1) > CVSHEETY
	
	MSG("NEXT PART OFF SHEET!" << CVPARTY*(CVLY+1));
	M00;
			GOTOF PROG_END
	ENDIF
MSG("XmaxLeft:" << CVPARTX*(CVLX+1)) << " YmaxTop:" << CVPARTY*(CVLY+1));
GOTOB REPSTART_SETG54;
ENDIF

PROG_END:
G01 Z=500;moveaway
G500
Y = 400;
;=========END OF REP LOGIC====
`

                        operateOnTransformedLSTParts(
                            (nufnm, nu_LST_headers, outputGcodeStr, global_LST_footers) => {
                         nu_LST_headers
                                str = [nu_LST_headers, STRING_definitions, outputGcodeStr, global_LST_footers].join("\n")
                                //put definitions at the very start of the program
                                nu_LST_headers = nu_LST_headers.replace(START_TEXT, [START_TEXT, STRING_definitions].join("\n"))

                                window.outLST = {
                                    nu_LST_headers, STRING_loop_logic, outputGcodeStr, STRING_loop_inc, global_LST_footers
                                }
                                console.error("TODO TODO TODO TODO no semicolon before END_OF_PROGRAM monkey fix!!!")
                                outLSTstr = [nu_LST_headers,outputGcodeStr,";" + global_LST_footers].join("\n")
								//STRING_loop_logic, STRING_loop_inc

								const splitter = new StringSplitter(outLSTstr);
								var jumpToLogic = 
`
GOTOF REPLOGIC;for testing
`

                                splitter.insertAfter('SET_G54', STRING_loop_logic);
                                splitter.insertAfter('END_OF_HEADER', jumpToLogic);
                                splitter.insertAfter('END_OF_PROGRAM', STRING_loop_inc);
                                const updatedString = splitter.toString();

                                // Swal.fire(`remember if you need less 
                                // parts you can always change CV_COL_X_LAST
                                // at the start of the program. This type of repetition 
                                // is easier to modify during on-line programming`+ JSON.stringify(strvs))
                                saveText(updatedString, nufnm + ".LST")

                                return;

                            })


                    })()


                }


                function MakeRowUI() {
                    if (!blockselection.length) {
                        return swal.fire("please select blocks to repeat first")
                    }
                    let maxY = prompt("enter sheet Y size in mm", "1250")
                    let dist = prompt("enter distance between blanks mm", "5")
                    if (!maxY) return;
                    if (!dist) return;
                    maxY = parseInt(maxY)
                    dist = parseInt(dist)
                    if (isNaN(maxY)) return;
                    if (isNaN(dist)) return;
                    MakeRow(blockselection, maxY, dist)
                }

                function scaleProgtoFit(maxX, maxY) {
                    throw Error("unimplemented")
                    let bbx = calcBoundBox(blocks.flat())
                    let howbigisOnePart = bbx.rangeY;
                    // let normalised = howbigisOnePart
                    // let scaledmax = howbigisOnePart * 0.5
                    // let scaledbbox = howbigisOnePart
                }




                function moveBlocksBeforeBlock() {

                }

                function selectSimilarBlocks(tol) {
                    say({ tol })
                    //TODO NOW
                    if (blockselection.length > 1) {
                        return swal.fire("select one block only, multiblock similarity not yet supported.")
                    }
                    block1 = blockselection[0]
                    bbox1 = calcBoundBox(block1, s => s.onoffevap !== 0)
                    let similarBlocks = []
                    blocks.forEach(block2 => {
                        let bbox2 = calcBoundBox(block2, s => s.onoffevap !== 0)
                        let nSimSizeB = Bbox1SimilarSizeBBox2(bbox1, bbox2, tol)
                        if (nSimSizeB) {
                            similarBlocks.push(block2)
                        }
                    })
                    metablock_select_set(blocks, false)
                    metablock_select_set(similarBlocks, true)
                    drawFromPoints(blocks)
                }

                function selectEverythingBetweenTwoBlocks(tol) {
                    //TODO NOW for last selected , selects all similar

                }

                function selectEverythingBetweenSelectedAndLastSimilarBlock(tol) {
                    //TODO NOW only one selected block has to be                 

                }



                const ops = { moveSelectionInTime, RepeatBlocksinAxis, deleteSelectedBlocksRange, reverseAllBlocks, deleteBlocks, deleteBlockByBlockNumbers, selectBlocks, copymovetranslateBlocksWhere, getBlockByBNumber }


                //noontz
                //https://stackoverflow.com/questions/11112321/how-to-save-canvas-as-png-image/58652379#58652379
                function DownloadCanvasAsImage() {
                    curBGindex = 1;
                    drawFromPoints(blocks)
                    let downloadLink = document.createElement('a');

                    downloadLink.setAttribute('download', fnm + 'blankEZ.png');
                    canvas.toBlob(function (blob) {
                        let url = URL.createObjectURL(blob);
                        downloadLink.setAttribute('href', url);
                        downloadLink.click();
                    });
                }

                function toggleCanvasTransparency() {
                    curBGindex = (!curBGindex & !curBGindex)
                    curCanvasBG = BGcolors[curBGindex]
                    return curBGindex;
                }

            </script>



            <script>
                var dragged = false
                var mousedowned = false;
                window.addEventListener('load', function () {

                    let obj = draggableCorner

                    var dragged = false
                    var mousedowned = false;
                    obj.addEventListener('mousedown', function () {
                        mousedowned = true;
                        dragged = false

                    }, true)
                    obj.addEventListener('mousemove', function (event) {

                        if (mousedowned) {
                            dragged = true
                            moveControls(event)
                        }
                    }, true)
                    window.addEventListener('mouseup', function () {
                        mousedowned = false;
                        if (dragged == true) {
                            return
                        }
                    }, true)



                    obj.addEventListener('mydragevent', function (event) {
                        event.preventDefault();
                        moveControls(event);
                    }, true)

                    obj.addEventListener('touchmove', function (event) {
                        event.preventDefault();
                        moveControls(event);
                    }, false);

                    obj.addEventListener('', function (event) {
                        event.preventDefault();
                        moveControls(event);
                    }, false);

                    obj.addEventListener('touchcancel', function (event) {
                        event.preventDefault();
                        moveControls(event);
                    }, false);

                    // }

                })

                window.addEventListener('mousedown', function (event) {
                    mousedowned = true;
                    dragged = false
                    moveControls(event);
                }, false)
                window.addEventListener('mousemove', function (event) {

                    if (mousedowned) {
                        dragged = true
                        moveControls(event)
                    }
                }, true)
                window.addEventListener('mouseup', function () {
                    mousedowned = false;
                    if (dragged == true) {
                        return
                    }
                }, true)

                function moveControls(event) {



                    var touch = event.targetTouches ? event.targetTouches[0] : event;
                    if (touch) {
                        // Place element where the finger is

                        var sX = window.pageXOffset;
                        var sY = window.pageYOffset;


                        Ex = touch.pageX < 0 ? "200px" : touch.pageX - sX;
                        Ey = touch.pageY < 0 ? (console.log("touch beyond screen!:" + touch.pageY), '1000px') : touch.pageY - sY;
                        Ex < 100 ? Ex = 100 : 0;
                        Ey < 100 ? Ey = 100 : 0;


                        let parel = event.target.parentElement
                        if (parel) {
                            Tstyle = parel.style;

                            TzoomF = (Tstyle.zoom.replace("%", "") / 100).toFixed(2);



                            eZ.ctrls.cX = Tstyle.left = (Ex / TzoomF).toFixed(2) + 'px';
                            eZ.ctrls.cY = Tstyle.top = (Ey / TzoomF).toFixed(2) + 'px';

                        }

                        // console.log();


                        //event.target.innerText="â†¹:\n"+ctrls.cX+"\n"+ctrls.cY;
                    }
                }
                var eZ = {
                    ctrls: {
                        cX: 0,
                        cY: 0,
                    }
                }

            </script>


</body>

</html>